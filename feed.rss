<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>That About Sums It Up</title><description>write is code, think ux design.</description><link>https://agiletalk.github.io</link><language>ko</language><lastBuildDate>Tue, 5 Apr 2022 23:51:10 +0900</lastBuildDate><pubDate>Tue, 5 Apr 2022 23:51:10 +0900</pubDate><ttl>250</ttl><atom:link href="https://agiletalk.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://agiletalk.github.io/posts/pragmatic-projects</guid><title>실용주의 프로젝트</title><description></description><link>https://agiletalk.github.io/posts/pragmatic-projects</link><pubDate>Tue, 5 Apr 2022 23:55:00 +0900</pubDate><content:encoded><![CDATA[<h1>실용주의 프로젝트</h1><h2>오늘 TIL 3줄 요약</h2><ul><li>실현하려면 계획하라.</li><li>유행하는 것이 아니라 실제로 잘 맞는 것을 사용하라.</li><li>일찍 테스트하고, 자주 테스트하라. 자동으로 테스트하라.</li></ul><h2>TIL (Today I Learned) 날짜</h2><p><code>2022. 04. 05</code></p><h2>오늘 읽은 범위</h2><p>9장. 실용주의 프로젝트</p><h2>책에서 기억하고 싶은 내용을 써보세요.</h2><ul><li>소프트웨어 개발 방법론의 목표는 사람들이 함께 일하는 것을 돕는 것이다.</li><li><code>Tip 84</code> 작고 안정적인 팀을 유지하라.</li><li>팀 전체가 깨진 창문을 용납하지 않아야 한다. 사소함 결점을 아무도 고치지 않고 놔두어서는 안 되고, <strong>반드시</strong> 제품의 품질에 책임을 져야 한다.</li><li>여러분의 팀이 진정 개선하고 혁신하고 싶다면 계획을 세워야 한다.</li><li>지속적인 개선이 일어나려면 주위를 둘러보고 무엇이 잘되고 무엇이 잘되지 않았는지 확인한 다음 변화를 일으킬 시간이 있어야 한다.</li><li>매끄럽다는 것은 질문하기, 진행 상황이나 문제, 통찰 및 새롭게 알게 된 점을 공유하기, 또 동료가 뭘 하고 있는지 알고 있기가 쉽고 거추장스러운 단계가 적다는 뜻이다.</li><li><code>Tip 86</code> 모든 기능을 갖춘 팀을 조직하라.</li><li>일관성과 정확성을 모두 보장하는 확실한 방법은 팀이 하는 모든 일을 자동화하는 것이다.</li><li>각 팀원이 자신의 방식대로 빛나게 하라. 팀원들을 지원하기에, 그리고 프로젝트가 가치를 만들어 내기에 딱 좋을 만큼의 구조를 제공하라.</li><li>"잘 맞는 것"을 어떻게 알 수 있을까? 한번 해 보라.</li><li>진짜 목표는 작동하는 소프트웨어를 제공 함으로써 사용자가 <strong>즉각적으로</strong> 새로운 일을 할 수 있게 되는 것이다.</li><li>빌드와 릴리스 과정이건, 테스트나 프로젝트 서류 작업이건, 혹은 프로젝트에서 거듭 발생하는 다른 어떤 작업이건 간에 일상적인 작업은 모두 자동화해야 한다.</li><li><code>Tip 89</code> 버전 관리 시스템으로 빌드, 테스트, 릴리스를 운용하라.</li><li>코드를 작성하자마자 테스트해야 한다.</li><li><code>Tip 91</code> 모든 테스트가 끝날 때까지는 코딩이 끝난 게 아니다.</li><li>어떤 버그를 감지해 내는 테스트를 작성한 후에, 그 버그가 의도적으로 생기도록 한 다음 테스트가 경보를 울리는지 확인하라. 이렇게 하면 실제로 버그가 생겼을 때 테스트가 그걸 잡아낼 것이라고 확신할 수 있다.</li><li>버그가 기존 테스트의 그물을 빠져나갔다면 다음번에는 그걸 잡아낼 수 있도록 새 테스트를 추가해야 한다.</li><li>개발자로서 우리의 목표는 <strong>사용자를 기쁘게</strong> 하는 것이다.</li><li>도메인에 대한 우리의 지식이 늘어남에 따라 근본적인 사업 문제를 해결하기 위해 우리가 맡지 않은 다른 부분에 대해서도 더 좋은 제안을 할 수 있게 된다.</li><li><code>Tip 96</code> 사용자를 기쁘게 하라. 그저 코드만 내놓지 말라.</li><li><strong>사람들이 코드에 붙은 여러분의 이름을 보고 그것이 튼튼하고 잘 작성되었으며 제대로 테스트되었을 뿐 아니라 훌륭히 문서화되었을 것이라고 기대하도록 만들자.</strong></li></ul><h2>오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요.</h2><p>하루하루 새로 생겨나는 요구 사항을 해결하며 일상적인 반복을 하면서 '본질'을 놓치고 있었던 건 아닌지 하는 생각이 들었다. 내가, 더 나아가서 우리가 무엇을 위해 일하고 어떻게 함께 일해야 하는지, 기존의 관습을 쳇바퀴처럼 따르는 것이 아니라 왜 개선해야 하는지 생각해보게 되었다. 같이 프로젝트 하는 동료들도 읽어보면 좋을 것 같은 내용이었다!</p><h2>오늘 읽은 다른사람의 TIL</h2><p><a href="https://velog.io/@xmun74/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-2022.04.05-9%EC%9E%A5.%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8">실용주의 프로그래머 - 2022.04.05 - 9장.실용주의 프로젝트</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://agiletalk.github.io/posts/before-the-project</guid><title>프로젝트 전에</title><description></description><link>https://agiletalk.github.io/posts/before-the-project</link><pubDate>Mon, 4 Apr 2022 01:10:00 +0900</pubDate><content:encoded><![CDATA[<h1>프로젝트 전에</h1><h2>오늘 TIL 3줄 요약</h2><ul><li>프로그래머는 사람들이 자신이 원하는 바를 깨닫도록 돕는다.</li><li>요구 사항은 피드백을 반복하며 알게 된다.</li><li>사용자처럼 생각하기 위해 사용자와 함께 일하라.</li></ul><h2>TIL (Today I Learned) 날짜</h2><p><code>2022. 04. 03</code></p><h2>오늘 읽은 범위</h2><p>8장. 프로젝트 전에</p><h2>책에서 기억하고 싶은 내용을 써보세요.</h2><ul><li>완성이라는 것은 더 이상 더할 것이 없을 때가 아니라, 더 이상 뺄 것이 없을 때 달성되는 것이다.</li><li><code>Tip 75</code> 자신이 뭘 원하는지 정확히 아는 사람은 아무도 없다.</li><li>우리의 일은 사람들이 자신이 원하는 바를 깨닫도록 돕는 것이다. 사실 이게 우리의 가치가 가장 빛나는 부분일 것이다.</li><li>우리는 모형이나 프로토타입을 만들어서 의뢰인이 직접 다루어 볼 수 있도록 한다. 만든 모형이나 프로토타입이 이리저리 바꾸기 쉬워서 의뢰인과 대화하는 도중에도 계속 바꿀 수 있다면 이상적이다.</li><li>그러니 실용주의 프로그래머는 프로젝트 <strong>전체</strong>를 요구 사항 수집 과정으로 보아야 한다.</li><li>현재의 정책 정보는 시스템이 지원하는 것들 중 한 사례일 뿐이고, 시스템은 다양한 정책을 처리할 수 있도록 일반적으로 구현해야 한다.</li><li>우리는 최고의 요구 사항 문서, 아니 아마 유일한 요구 사항 문서는 작동하는 코드라고 믿는다.</li><li>문서는 구현 과정에서 안내 역할을 하는 이정표일 뿐이다.</li><li>요구 사항 설명을 짧게 제한하면 개발자들이 명확하지 않은 점을 물어보도록 유도할 수 있다. 코드를 작성하기 전이나 작성하는 도중에 일어나는 의뢰인과 개발자 간의 피드백 과정이 더 활발해지는 것이다.</li><li><strong>좋은 요구 사항은 추상적이다.</strong> 요구 사항을 기술할 때는 사업에 필요한 사항을 정확히 반영하는 가장 간단한 표현이 최고다.</li><li>요구 사항은 아키텍처가 아니다. 요구 사항은 설계가 아니며 사용자 인터페이스도 아니다. 요구 사항은 <strong>필요</strong>를 표현하는 것이다.</li><li>만들고 있는 소프트웨어를 직접 사용할 수 있는가? 직접 소프트웨어를 사용하지 못하는데 요구 사항에 대해 감을 잡을 수 있을까?</li><li>어떤 퍼즐이든 그것을 해결하는 열쇠는 제약을 인식하는 것과 더불어 여러분에게 <strong>주어진</strong> 자유도를 파악하는 것이다. 퍼즐의 해답은 그 자유도 안에서 발견된다.</li><li><code>Tip 81</code> 생각의 틀을 벗어나지 말고, 틀을 찾아라.</li><li>여러분의 뇌에 경험을 주입하는 가장 좋은 방법은 일상적인 작업을 할 때 무엇은 잘되고 무엇은 안되는지 피드백을 주는 것이다.</li><li>한 사람이 코드를 입력하는 동안 한 명 혹은 여러 명의 팀 동료가 조언하고 고민하며 문제를 함께 푸는 것이다. 이 방식은 함께 일하는 아주 강력한 방법이다.</li><li>이것이 우리가 말하는 "함께 일하기"다. 그저 질문하고, 토론하고 메모를 하는 것이 아니라, <strong>실제로 코딩을 하는 와중에</strong> 질문을 하고 토론을 하는 것이다.</li><li>입력을 담당한 개발자는 문법이나 코딩 스타일 같은 낮은 수준의 세부 사항에 집중해야만 한다. 반면에 다른 개발자는 문제를 더 높은 수준에서 넓은 범위를 보며 고민할 수 있다.</li><li><code>Tip 83</code> 애자일은 명사가 아니다. 애자일은 무언가를 하는 방식이다.</li><li>애자일의 가치는 소프트웨어를 만드는 더 나은 방법을 지속적으로 탐구하는 과정에서 찾고 알게 되는 것이기 때문이다.</li><li>애자일이 전반적으로 작동하게 하려면 좋은 설계를 만들어야 한다. 좋은 설계는 무언가를 바꾸기 쉽게 하기 때문이다. 바꾸기 쉽다면 모든 층위에서 아무런 주저 없이 문제를 바로잡을 수 있을 것이다. 이것이 애자일이다.</li></ul><h2>오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요.</h2><p>요구 사항과 애자일 부분에서 그동안 회사에서 한 경험과 프로젝트가 생각났다. 나는 요구 사항을 잘 이해하고 해결하고 있는가, 정말로 함께 일하고 있는가, 우리가 하는 건 애자일이 맞을까 등등.. 조금 더 많이 고민해봐야겠다!</p><p>짝 프로그래밍 이야기가 나왔는데 어렴풋이 찍먹만 해봤던 기억이 나서 스쿼드 프로젝트 진행하면서 한번 적용해봐야겠다는 생각이 들었다. 일단 해보자고~</p><h2>궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.</h2><p>불가능한 퍼즐 풀기는 내가 생각의 틀을 벗어나지 못한 것 같다.</p><h2>오늘 읽은 다른사람의 TIL</h2><p><a href="https://hyuuny.tistory.com/71">TIL 8 실용주의 프로그래머 #8. 프로젝트 전에</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://agiletalk.github.io/posts/bend-or-break</guid><title>구부러지거나 부러지거나</title><description></description><link>https://agiletalk.github.io/posts/bend-or-break</link><pubDate>Sun, 27 Mar 2022 02:13:00 +0900</pubDate><content:encoded><![CDATA[<h1>구부러지거나 부러지거나</h1><h2>오늘 TIL 3줄 요약</h2><ul><li>결합도가 낮은 코드가 바꾸기 쉽다.</li><li>프로그래밍은 코드에 관한 것이지만, 프로그램은 데이터에 관한 것이다.</li><li>다형성은 인터페이스로 표현하는 것이 좋다.</li></ul><h2>TIL (Today I Learned) 날짜</h2><p><code>2022. 03. 26</code></p><h2>오늘 읽은 범위</h2><p>5장. 구부러지거나 부러지거나</p><h2>책에서 기억하고 싶은 내용을 써보세요.</h2><ul><li>소프트웨어 구조는 유연해야 한다.</li><li><code>Tip 45</code> 묻지 말고 말하라. (Tell, Don't Ask, TDA.)</li><li>이 원칙은 다른 객체의 내부 상태에 따라 판단을 내리고 그 객체를 갱신해서는 안 된다는 것이다.</li><li>무언가에 접근할 때 "."을 딱 하나만 쓰려고 노력해 보라. '무언가에 접근'한다는 건 중간 변수를 사용하는 경우까지 포함해야 한다.</li><li><strong>코드를 재사용할 수 있게 하려면 깨끗한 인터페이스를 만들고 나머지 코드와의 결합을 없애야 한다.</strong></li><li><code>Tip 47</code> 전역 데이터를 피하라.</li><li>직접적으로 아는 것만 다루는 부끄럼쟁이 코드를 계속 유지하라.</li><li>어디에서 온 것이든 애플리케이션을 이런 이벤트에 반응하도록, 그리고 그에 기반해서 하는 일을 조절하도록 만들면, 진짜 세상에서 더 잘 작동하는 애플리케이션이 탄생할 것이다. 사용자들은 애플리케이션의 상호 작용이 더 원활하다고 느낄 것이고 애플리케이션 자체는 리소스를 더 효율적으로 사용할 것이다.</li><li>이벤트가 어디서 발생하든 이벤트를 중심으로 공들여 만든 코드는 일직선으로 수행되는 코드보다 더 잘 반응하고 결합도가 더 낮다.</li><li>프로그램이란 입력을 출력으로 바꾸는 것이라는 사고방식으로 돌아갈 필요가 있다. 이렇게 생각하면 그동안 고민하던 많은 세부 사항이 모두 사라진다. 구조는 명확해지고 더 일관적으로 오류를 처리하게 되어 결합도 대폭 줄어들 것이다.</li><li>요구 사항에서 입력과 출력이 무엇인지 찾으면 전체 프로그램을 나타내는 함수가 정해진다.</li><li>데이터를 전체 시스템 여기저기의 작은 웅덩이에 흩어 놓는 대신, 데이터를 거대한 강으로, <strong>흐름</strong>으로 생각하라.</li><li>아무리 복잡한 클래스 계층도가 마음에 들더라도 어차피 여러분의 도메인을 정확하게 모델링할 수는 없다.</li><li><code>Tip 53</code> 서비스에 위임하라. Has-A가 Is-A보다 낫다.</li><li>프로그래밍의 다른 모든 것과 마찬가지로 여러분의 목표는 의도를 가장 잘 드러내는 기법을 사용하는 것이어야 한다.</li><li>애플리케이션이 출시된 이후 바뀔 수도 있는 값에 코드가 의존하고 있다면 그 값을 애플리케이션 외부에서 관리하라. 여러분의 애플리케이션이 여러 환경에서 혹은 여러 고객을 위해 실행된다면 특정 환경이나 특정 고객에게 한정된 값을 애플리케이션 외부에서 관리하라.</li><li>대신 설정 정보를 (얇은) API 뒤로 숨겨라. 그러면 설정을 표현하는 세부 사항으로부터 여러분의 코드를 떼어놓을 수 있다.</li></ul><h2>오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요.</h2><p>이벤트에 잘 반응하는 애플리케이션 만드는 전략들을 소개하는 부분이 재미있었다. iOS 개발하면서 많이 경험했던 것들도 있었고, FSM은 한번 적용해보고 싶었다.</p><p>루비, 엘릭서로 작성된 예제 코드도 재미있었다.</p><h2>오늘 읽은 다른 사람의 TIL</h2><p><a href="https://flynndev.notion.site/2022-03-26-DAY-09-292b9b659e264c0b81a2d3a626786418">2022. 03. 26. DAY 09</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://agiletalk.github.io/posts/the-basic-tools</guid><title>기본 도구</title><description></description><link>https://agiletalk.github.io/posts/the-basic-tools</link><pubDate>Thu, 24 Mar 2022 02:16:00 +0900</pubDate><content:encoded><![CDATA[<h1>기본 도구</h1><h2>오늘 TIL 3줄 요약</h2><ul><li>지식을 일반 텍스트로 저장하라.</li><li>비난 대신 문제를 해결하라.</li><li>코드를 고치기 전 실패하는 테스트부터.</li></ul><h2>TIL (Today I Learned) 날짜</h2><p><code>2022. 03. 23</code></p><h2>오늘 읽은 범위</h2><p>3장. 기본 도구</p><h2>책에서 기억하고 싶은 내용을 써보세요.</h2><ul><li>사람이 읽을 수 있는 형태의 데이터와 그 자체만으로 의미가 드러나는 데이터는 다른 어떤 형태의 데이터보다, 심지어 그 데이터를 생성한 애플리케이션보다 더 오래 살아남을 것이다.</li><li>GUI의 장점은 WYSIWYG, 즉 여러분이 보는 것이 여러분이 얻는 것이라는 점이지만, 단점은 WYSIWYG, 즉 여러분이 보는 것이 여러분이 얻는 <strong>전부</strong>라는 것이다.</li><li><code>Tip 26</code> 명령어 셸의 힘을 사용하라.</li><li>무언가 같은 일을 반복하는 것을 발견할 때마다 이렇게 생각하는 습관을 들여라. '분명 더 나은 방법이 있을 텐데.' 그리고 더 나은 방법이 있는지 찾아보라.</li><li>여러분이 늘 하는 반복적인 일을 자동화할 방법을 연구해 보라.</li><li>바르게 설정된 버전 관리 시스템이 있으면 <strong>소프트웨어의 이전 버전으로 언제든지 되돌아갈 수 있다.</strong></li><li>프로젝트 이외의 것에도 버전 관리를 사용하라.</li><li>디버깅은 단지 <strong>문제 풀이</strong>일 뿐이라는 사실을 받아들이고, 그런 마음으로 공략하라.</li><li>버그가 여러분의 잘못인지 다른 사람의 잘못인지는 중요치 않다. 어쨌거나 그 버그를 해결해야 하는 사람은 여러분이다.</li><li>버그를 고치는 첫걸음으로 가장 좋은 것은 그 버그를 재현할 수 있게 만드는 것이다.</li><li><code>Tip 34</code> 가정하지 말라. 증명하라.</li><li>놀라운 버그를 마주쳤을 때, 단순히 그걸 고치는 것을 넘어서 왜 이 문제가 더 일찍 발견되지 않았을까 생각해 봐야 한다. 버그를 미리 잡을 수 있도록 단위 테스트나 다른 테스트를 수정할 필요가 있는지 고민해 보라.</li><li><code>Tip 35</code> 텍스트 처리 언어를 익혀라.</li><li>회의에서 메모할 때나 작업하는 내용을 써 놓을 때, 디버깅하다가 변수의 값을 적어 놓을 때, 무엇을 어디 두었는지 기록을 남길 때, 엉뚱한 생각을 기록할 때, 아니면 때로는 그냥 낙서할 때 일지를 쓴다.</li><li>그러니 엔지니어링 일지를 남겨 보라. 파일이나 위키말고 종이를 사용하라. 글씨를 쓰는 것은 키보드를 두드리는 것과는 다른 무언가 특별한 것이 있다. 일단 한 달만 써 보고 어떤 이득을 얻었는지 살펴보라.</li></ul><h2>오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요.</h2><p>셸과 에디터(예를 들면, vi)를 조금 더 유창하게 쓸 수 있게 연습해야 할 것 같다.</p><p>각종 설정 파일과 Homebrew 설치 목록을 버전 관리 시스템으로 관리해야겠다.</p><p>엔지니어링 일지를 써볼까? 그런데 굳이 종이를 사용해야 할까?</p><h2>오늘 읽은 다른사람의 TIL</h2><p><a href="https://cindybaby.notion.site/DAY-06-35b4f224a39c4b4b9d67a340271780cc">DAY 06</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://agiletalk.github.io/posts/pragmatic-approach</guid><title>실용주의 접근법</title><description></description><link>https://agiletalk.github.io/posts/pragmatic-approach</link><pubDate>Tue, 22 Mar 2022 02:00:00 +0900</pubDate><content:encoded><![CDATA[<h1>실용주의 접근법</h1><h2>오늘 TIL 3줄 요약</h2><ul><li>좋은 설계는 나쁜 설계보다 바꾸기 쉽다.</li><li>DRY: 반복하지 말라 (Don’t Repeat Yourself)</li><li>최종 결정이란 없다.</li></ul><h2>TIL (Today I Learned) 날짜</h2><p><code>2022. 03. 21</code></p><h2>오늘 읽은 범위</h2><p>2장. 실용주의 접근법</p><h2>책에서 기억하고 싶은 내용을 써보세요.</h2><ul><li><code>Tip 14</code> 좋은 설계는 나쁜 설계보다 바꾸기 쉽다.</li><li>잘 설계된 코드는 바뀜으로써 사용하는 사람에게 맞춰져야 한다.</li><li><strong>바뀌기 더 쉽게 (Easier to Change).</strong></li><li>앞으로 어떤 모습으로 바뀔지 잘 모르겠을 때 언제건 궁극의 '바꾸기 쉽게'라는 길을 선택한다. 바로 여러분이 작성하는 코드를 교체하기 쉽게 만들도록 노력하는 것이다.</li><li>교체 가능하게 작성하라는 말은 코드의 결합도를 낮추고 응집도를 높이라는 이야기일 뿐이다.</li><li>프로그래머는 늘 유지 보수 모드에 있다. 우리의 이해는 날마다 바뀐다. 우리가 프로젝트에 열중해 있는 동안에도 새로운 요구 사항이 도착하고 기존 요구 사항은 진화한다. 어쩌면 환경이 변할 수도 있다. 이유가 무엇이건, 유지 보수는 별개의 활동이 아니며 전체 개발 과정의 일상적인 부분이다.</li><li>우리는 DRY가 '실용주의 프로그래머'의 도구 상자에서 가장 중요한 도구 중 하나라고 생각한다.</li><li>언어나 기술에 중립적인 형식으로 내부 API를 정의할 수 있는 도구를 찾아보라. 이런 도구는 일반적으로 문서와 목(Mock) API, 기능 테스트를 생성해 주고, API 클라이언트도 여러 가지 언어로 생성해 준다. 이상적으로 이 도구를 이용하여 모든 API 정의를 중앙 저장소에 넣어 두고 여러 팀이 공유할 수 있게 하면 좋다.</li><li>개발자 간의 중복에 대처하려면 크게는 의사소통을 잘하는 튼튼하고 유대가 돈독한 팀을 만들어야 한다.</li><li>우리가 느끼기에 최선책은 개발자 간에 적극적이고 빈번한 소통을 장려하는 것이다.</li><li>그리고 일상적으로든 코드 리뷰를 통해서든 다른 사람의 소스 코드와 문서를 반드시 읽어라. 다른 사람의 것을 기웃거리는 게 아니고, 거기서 배우는 것이다.</li><li>(직교성은) 일종의 독립성이나, 결합도 줄이기를 의미한다. 하나가 바뀌어도 나머지에 어떤 영향도 주지 않으면 서로 직교한다고 할 수 있다.</li><li>직교적인 시스템을 작성하면 두 가지 큰 장점이 있다. 바로 생산성 향상과 리스크 감소다.<ul><li>생산성 향상<ul><li>변화를 국소화해서 개발 시간과 테스트 시간이 줄어든다. 새로운 코드를 추가할 때마다 기존의 코드를 계속 바꾸지 않아도 된다.</li></ul></li><li>리스크 감소<ul><li><strong>직교적인 시스템은 그 안의 컴포넌트들에 대해 테스트를 설계하고 실행하기 훨씬 쉽기 때문에, 아무래도 테스트를 더 많이 하게 된다.</strong></li></ul></li></ul></li></ul><ul><li>'특정 기능에 대한 요구 사항을 대폭 변경하는 경우 몇 개의 모듈이 영향을 받는가?' 직교적인 시스템에서는 답이 '하나'여야 한다.</li><li>'부끄럼쟁이' 코드를 작성하라. 즉, 불필요한 것은 다른 모듈에 보여 주지 않으며, 다른 모듈의 구현에 의존하지 않는 코드를 작성하라. 객체의 상태를 바꿀 필요가 있다면 여러분을 위해 객체가 직접 상태를 바꾸게 하라.</li><li>일반적으로는 필요한 컨텍스트를 모듈에 명시적으로 넘겨주면 코드를 이해하고 유지 보수하기 쉬워진다.</li><li>'리팩터링' - 기회가 있을 때마다 코드의 구조와 직교성을 개선하기 위해 노력하는 과정</li><li><strong>단위 테스트를 작성하는 행위 자체가 직교성을 테스트해 볼 수 있는 기회다.</strong> 단위 테스트를 빌드하고 실행하기 위해 어떤 작업이 필요한가? 나머지 시스템 중 상당 부분을 불러와야 하지는 않는가? 만약 그렇다면 모듈과 나머지 시스템 사이의 결합도를 충분히 줄이지 못했다는 뜻이다.</li><li>당연한 말이겠지만 DRY 원칙으로 무장하고 직교성 원칙을 충실히 적용한다면 개발하고 있는 시스템이 더 유연하고 이해하기 쉬워질 것이다. 디버깅, 테스트, 유지 보수 또한 쉬워질 것이다.</li><li>되돌릴 수 없는 결정을 줄여야 하는 까닭은 우리가 프로젝트 초기에 늘 최선의 결정을 내리지는 못하기 때문이다. 우리가 소프트웨어를 개발하는 속도는 요구 사항, 사용자, 하드웨어의 변화를 앞지를 수 없다.</li><li>결정이 바뀌지 않을 것이라고 가정하고서 발생할지도 모를 우연한 사건에 대비하지 않는 데에서 실수가 나온다. 결정이 돌에 새겨진 것이 아니라 바닷가의 모래 위에 쓰인 글씨라 생각하라. 언제든지 큰 파도가 글씨를 지워버릴 수 있다.</li><li><code>Tip 19</code> 유행을 쫓지 말라.</li><li>전에 만들어진 적이 없는 전혀 새로운 것을 만들고 있다면 더욱 그렇다. 움직이는 목표물을 맞히려면 실제 조건하에서 즉각적인 피드백을 받아야 한다. 우리는 이것을 시각적으로 묘사하기 위해 '예광탄 개발'이라는 말을 쓴다.</li><li>코딩에서 동일한 효과를 얻으려면 우리를 요구 사항으로부터 최종 시스템의 일부 측면까지 빨리, 눈에 보이게, 반복적으로 도달하게 해 줄 무언가를 찾아야 한다.</li><li>시스템을 정의하는 중요한 요구 사항을 찾아라. 의문이 드는 부분이나 가장 위험이 커 보이는 곳을 찾아라. 이런 부분의 코드를 가장 먼저 작성하도록 개발 우선순위를 정하라.</li><li><strong>예광탄 개발 방법은 '프로젝트는 결코 끝나지 않는다.'는 견해와도 일맥상통한다. 변경 요청과 기능 추가 요청은 언제나 계속 들어오기 마련이다. 예광탄 개발 방법은 점진적인 접근 방법이다.</strong></li><li><strong>프로토타이핑은 학습 경험이다.</strong> 프로토타이핑의 가치는 생산한 코드에 있는 것이 아니라 이를 통해 배우는 교훈에 있다. 이것이 프로토타이핑의 진정한 핵심이다.</li><li>우리는 언제나 애플리케이션 도메인의 어휘를 사용해서 코드를 작성하려고 노력한다.</li><li><code>Tip 22</code> 문제 도메인에 가깝게 프로그래밍하라.</li><li>모든 추정치는 문제의 모델에 기반한다. 그런데 모델을 작성하는 기술에 대해 깊이 파고들기 전에 항상 좋은 답을 알려주는 기본적인 추정의 비법을 하나 밝히겠다. 이미 그 일을 해본 사람에게 물어보라.</li><li>어떤 종류의 추정을 하건 첫 단계는 상대방이 무엇을 묻고 있는지 이해하는 것이다. 조건이 질문에 명시적으로 드러나지 않는 경우도 많지만, 여러분이 추정하기 전에 미리 어떤 조건이 있을지 생각하는 습관을 길러야 한다.</li><li>그러므로 초기 기능의 구현과 테스트를 마친 후, 이를 첫 번째 반복 주기의 끝으로 삼아라. 첫 반복 주기의 경험을 바탕으로 반복 주기의 수와 각 반복 주기에서 무엇을 할지에 대한 처음의 추측을 다듬을 수 있을 것이다.</li><li>여러분이 계산한 추정치를 기록으로 남겨라. 그리고 각 추청치가 얼마나 정확했는지도 기록으로 남겨라.</li></ul><h2>오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요.</h2><p>DRY에 대해서는 많이 들어봤는데 코드 말고도 중복을 피해야 할 곳이 많다는 사실을 알았다.</p><p>우리가 내린 결정과 요구 사항, 사용자는 계속 변화하기 때문에 유연한 시스템을 만들어야 한다.</p><p>프로토타입과 예광탄 개발을 구분하고, 앞으로는 예광탄 개발을 해봐야겠다.</p><h2>궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.</h2><ul><li>도메인 언어와 추정은 한 번 더 읽어보자!</li></ul><h2>오늘 읽은 다른사람의 TIL</h2><p><a href="https://hyuuny.tistory.com/56">TIL 2 실용주의 프로그래머 #2. 실용주의 접근법</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://agiletalk.github.io/posts/pragmatic-philosophy</guid><title>실용주의 철학</title><description></description><link>https://agiletalk.github.io/posts/pragmatic-philosophy</link><pubDate>Sat, 19 Mar 2022 22:00:00 +0900</pubDate><content:encoded><![CDATA[<h1>실용주의 철학</h1><h2>오늘 TIL 3줄 요약</h2><ul><li>자신의 기예에 관심을 가져라.</li><li>변화의 촉매가 되라.</li><li>지식 포트폴리오에 주기적으로 투자하라.</li></ul><h2>TIL (Today I Learned) 날짜</h2><p><code>2022. 03. 19.</code></p><h2>오늘 읽은 범위</h2><p>서문 ~ 1장. 실용주의 철학</p><h2>책에서 기억하고 싶은 내용을 써보세요.</h2><ul><li>무엇보다 중요한 것은 즐기는 것이다.</li><li><strong>"당신은 당신의 조직을 바꾸거나, 당신의 조직을 바꿀 수 있다."</strong></li><li>무엇보다 여러분의 팀이 여러분을 믿고 의지할 수 있어야 한다. 여러분도 다른 팀원 누구에게나 편하게 의지할 수 있어야 한다.</li><li>변명 말고 대안을 제시하라. 안된다고 하지 말고 상황을 개선하기 위해 무엇을 할 수 있는지 설명하라.</li><li>나쁜 설계, 잘못된 결정, 혹은 형편없는 코드 등이 모두 깨진 창문이다. 발견하자마자 바로 고쳐라.</li><li>여러분이 만드는 시스템의 범위와 품질은 해당 시스템의 요구 사항 중 하나로 논의되어야 한다.</li><li><strong>사용자에게 뭔가 직접 만져볼 수 있는 것을 일찍 준다면, 피드백을 통해 종국에는 더 나은 해결책에 도달할 수 있을 것이다.</strong></li><li>여러분의 기술 달걀을 모두 한 바구니에 담지 말라.</li><li>투자를 지속하는 것이 중요하다. 한 기술의 새로운 용어나 기능에 익숙해지면 다음으로 나아가라. 또 다른 것을 배워라.</li><li>코드를 작성하는 것은 우리의 의도를 기계에게 전달하는 것이기도 하지만, 생각을 기록하여 다음 세대의 개발자들에게 전달하는 것이기도 하다.</li><li><strong>다른 모든 형태의 의사소통과 마찬가지로 여기서도 비결은 피드백을 모으는 것이다. 그저 질문을 기다리지 말고 먼저 물어보라.</strong></li><li>실용주의 프로그래머는 문서화를 전체 개발 프로세스의 필요 불가결한 부분으로 받아들인다.</li></ul><h2>오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요.</h2><p>오랜만에 다시 읽는 책이지만 또 새롭다. 역시 본질은 달라지지 않는다. 그때 내용이 지금도 유효한 것들이 많다.</p><p>깨진 창문, 지식 포트폴리오, 문서화 이야기는 읽으면서 많이 반성하게 되었다. 인정했으니 이제 개선해보자!</p><p>지식 포트폴리오에 주기적으로 투자해야겠다. 일단 블로그부터 열심히 쓰고, 새로운 언어를 하나 배워봐야겠다~</p><h2>궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.</h2><ul><li>코드를 현재 상태로 한동안 그대로 놓아두어야 할 <strong>'적당히 괜찮은'</strong> 상태란 무엇일까? 어떤 기준으로 정할 수 있을까?</li></ul><h2>오늘 읽은 다른사람의 TIL</h2><p><a href="https://jiyoungyim100.notion.site/TIL-2022-03-19-1-fc4e455c01bb417dad864e915fca05cc">TIL (2022.03.19) - 서문 &amp; 1장. 실용주의 철학</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://agiletalk.github.io/posts/book-challenge-pragmatic</guid><title>실용주의 프로그래머</title><description></description><link>https://agiletalk.github.io/posts/book-challenge-pragmatic</link><pubDate>Fri, 18 Mar 2022 22:36:00 +0900</pubDate><content:encoded><![CDATA[<h1>실용주의 프로그래머</h1><img src="https://agiletalk.github.io/images/eb4c59d4-6d38-4fe4-8976-5511b714591f.JPG" alt="The Pragmatic Programmer"/><p>오늘부터 <a href="https://nomadcoders.co/pragmatic-programmer">노마드 챌린지</a>를 통해 실용주의 프로그래머 읽기 시작 📖</p>]]></content:encoded></item><item><guid isPermaLink="true">https://agiletalk.github.io/posts/first-post</guid><title>Start when you're ready</title><description></description><link>https://agiletalk.github.io/posts/first-post</link><pubDate>Sun, 1 Mar 2020 22:34:00 +0900</pubDate><content:encoded><![CDATA[<p>You've been building experience all your life. Don't ignore niggling doubts.</p><blockquote><p>The Pragmatic Programmer's 56th Tip.</p></blockquote>]]></content:encoded></item></channel></rss>